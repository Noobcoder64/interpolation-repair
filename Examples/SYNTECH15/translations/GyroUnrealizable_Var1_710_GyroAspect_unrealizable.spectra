module GyroUnrealizable_Var1_710_GyroAspect_unrealizable
env boolean frontDistSense_0;
env boolean backDistSense_0;
env boolean isReady;
sys boolean balancer_0;
sys boolean balancer_1;
sys boolean balancer_2;
guarantee
	alw (!(balancer_0 & !balancer_1 & balancer_2));
guarantee
	alw (!(balancer_0 & balancer_1 & !balancer_2));
guarantee
	alw (!(balancer_0 & balancer_1 & balancer_2));
guarantee
	!balancer_0 & !balancer_1 & !balancer_2;
guarantee
	alw ((!isReady) -> !balancer_0 & !balancer_1 & !balancer_2);
guarantee
	alw (!balancer_0 & !balancer_1 & balancer_2 -> !frontDistSense_0);
guarantee
	alw (!balancer_0 & balancer_1 & !balancer_2 -> !backDistSense_0);
guarantee
	alwEv (!balancer_0 & !balancer_1 & balancer_2);
guarantee
	alwEv (balancer_0 & !balancer_1 & !balancer_2 | !balancer_0 & balancer_1 & balancer_2);
guarantee
	alw ((isReady & !frontDistSense_0) -> !balancer_0 & !balancer_1 & balancer_2);
assumption
	!isReady;
assumption
	!frontDistSense_0 & !backDistSense_0;
assumption
	alwEv (isReady);
assumption
	alw (isReady -> next(isReady));
define
	moveAwayFromFrontObstacle := !(!balancer_0 & !balancer_1 & balancer_2 | !balancer_0 & !balancer_1 & !balancer_2);
assumption
	respondsTo(moveAwayFromFrontObstacle,(!moveAwayFromFrontObstacle) | !frontDistSense_0);
define
	moveAwayFromBackObstacle := !(!balancer_0 & balancer_1 & !balancer_2 | !balancer_0 & !balancer_1 & !balancer_2);
assumption
	respondsTo(moveAwayFromBackObstacle,(!moveAwayFromBackObstacle) | !backDistSense_0);
pattern respondsTo(trigger, response) {
var boolean responded;
responded;
alw (next(responded) iff (response or responded and !trigger));
alwEv (responded);
}
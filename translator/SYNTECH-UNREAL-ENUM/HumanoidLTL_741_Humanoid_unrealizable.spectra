
module HumanoidLTL_741_Humanoid_unrealizable

env {CLEAR, BLOCKED} obstacle;
env {QUIET, NOISE} noise;
env {N, SO} heading;
env {FREE, PRESSED} button;

sys {FWD, BWD, STOP, TURN_FWD, TURN_BWD, CALIB_TURN, CALIB_FWD} leftMotor;
sys {FWD, BWD, STOP, TURN_FWD, TURN_BWD, CALIB_TURN, CALIB_FWD} rightMotor;
sys {FWD, BWD, STOP} headMotor;
sys {FWD, BWD, TURN_LEFT_1, TURN_LEFT_2} nextMoveMode;
sys {Q0, Q1, Q2, Q3} spec_state;
sys {M0, M1} search;
sys {N, SO} next_head;

env boolean eNV_CONSTRAINT_0_respondsTo_responded;
env boolean eNV_CONSTRAINT_1_respondsTo_responded;
env boolean pREV_aux_2;
env boolean pREV_aux_3;
env boolean pREV_aux_4;

assumption
	alw (((((next(nextMoveMode = FWD)) | (next(nextMoveMode = BWD))) & !((heading = next_head))) -> !((next(heading = next_head)))));
assumption
	alw ((((next(nextMoveMode = FWD)) & (obstacle = BLOCKED)) -> (next(obstacle = BLOCKED))));
assumption
	alw ((((next(nextMoveMode = BWD)) & (obstacle = CLEAR)) -> !((next(obstacle = BLOCKED)))));
assumption
	alwEv (eNV_CONSTRAINT_0_respondsTo_responded);
assumption
	alwEv (eNV_CONSTRAINT_1_respondsTo_responded);

guarantee
	 (((search = M0) & (spec_state = Q0)));
guarantee
	alw ((next(next_head = N)));
guarantee
	alwEv (((next(nextMoveMode = FWD)) & (search = M0)));
guarantee
	alw (((((spec_state = Q0) & (next(nextMoveMode = FWD))) & (next(nextMoveMode = BWD))) -> (next(spec_state = Q1))));
guarantee
	alw (((((spec_state = Q1) & (next(nextMoveMode = BWD))) & (next(nextMoveMode = FWD))) -> (next(spec_state = Q2))));
guarantee
	alw (!((((spec_state = Q2) & (next(nextMoveMode = FWD))) & (next(nextMoveMode = BWD)))));
guarantee
	alw ((((next(nextMoveMode = TURN_LEFT_1)) | (next(nextMoveMode = TURN_LEFT_2))) -> (next(spec_state = Q0))));
guarantee
	alw (((((pREV_aux_2 & (noise = NOISE)) & !((heading = next_head))) & !((button = PRESSED))) -> (search = M1)));
guarantee
	alw (((pREV_aux_3 & (heading = next_head)) -> (search = M0)));
guarantee
	alw (((pREV_aux_3 & !((heading = next_head))) -> (search = M1)));
guarantee
	alw ((((next(obstacle = BLOCKED)) & !(pREV_aux_4)) -> !((next(nextMoveMode = FWD)))));
guarantee
	alw ((((next(nextMoveMode = BWD)) & (next(nextMoveMode = FWD))) <-> ((next(leftMotor = FWD)) & (next(rightMotor = BWD)))));
guarantee
	alw ((((next(nextMoveMode = FWD)) & (next(nextMoveMode = BWD))) <-> ((next(leftMotor = BWD)) & (next(rightMotor = FWD)))));
guarantee
	alw (((next(nextMoveMode = BWD)) -> ((next(nextMoveMode = FWD)) | (next(nextMoveMode = BWD)))));
guarantee
	alw (((next(nextMoveMode = TURN_LEFT_1)) -> ((next(leftMotor = FWD)) & (next(rightMotor = TURN_FWD)))));
guarantee
	alw (((next(nextMoveMode = TURN_LEFT_2)) -> ((next(leftMotor = BWD)) & (next(rightMotor = TURN_BWD)))));
guarantee
	alw (((next(nextMoveMode = TURN_LEFT_1)) <-> (next(nextMoveMode = TURN_LEFT_2))));
guarantee
	alw ((!(((next(nextMoveMode = TURN_LEFT_1)) | (next(nextMoveMode = TURN_LEFT_2)))) -> !(((((next(leftMotor = TURN_BWD)) | (next(rightMotor = TURN_BWD))) | (next(leftMotor = TURN_FWD))) | (next(rightMotor = TURN_FWD))))));
guarantee
	alw ((((next(nextMoveMode = FWD)) & (next(nextMoveMode = TURN_LEFT_1))) <-> ((next(leftMotor = CALIB_TURN)) & (next(rightMotor = CALIB_TURN)))));
guarantee
	alw ((((next(nextMoveMode = FWD)) & pREV_aux_4) <-> ((next(leftMotor = CALIB_FWD)) & (next(rightMotor = CALIB_FWD)))));
guarantee
	alw (((next(nextMoveMode = BWD)) -> !((next(nextMoveMode = TURN_LEFT_1)))));

assumption
	 (eNV_CONSTRAINT_0_respondsTo_responded);
assumption
	alw ((next(eNV_CONSTRAINT_0_respondsTo_responded) <-> ((heading = next_head) | (eNV_CONSTRAINT_0_respondsTo_responded & !((search = M1))))));
assumption
	 (eNV_CONSTRAINT_1_respondsTo_responded);
assumption
	alw ((next(eNV_CONSTRAINT_1_respondsTo_responded) <-> (((next(nextMoveMode = TURN_LEFT_2)) & (obstacle = CLEAR)) | (eNV_CONSTRAINT_1_respondsTo_responded & !((next(nextMoveMode = TURN_LEFT_2)))))));
assumption
	 (!(pREV_aux_2));
assumption
	alw ((next(pREV_aux_2) <-> (search = M0)));
assumption
	 (!(pREV_aux_3));
assumption
	alw ((next(pREV_aux_3) <-> (search = M1)));
assumption
	 (!(pREV_aux_4));
assumption
	alw ((next(pREV_aux_4) <-> (next(nextMoveMode = TURN_LEFT_2))));



module PCarLTL_Unrealizable_V_2_unrealizable0_888_PCar_fixed_unrealizable

env {CLEAR, BLOCKED} obstacle;
env {CLEAR, BLOCKED} sideSense;
env {NA, PARALLEL} parkResult;

sys {FWD, BWD, STOP} throttle;
sys {RIGHT, LEFT, CENTER} steer;
sys {START, STOP, CHECK} parkCommand;
sys {SEEKING, MEASURING, PARKING_0, PARKING_1, PARKING_2, PARKED} spec_policy;

env boolean eNV_CONSTRAINT_0_respondsTo_responded;
env boolean pREV_aux_1;

assumption
	alw (((spec_policy = SEEKING) -> (next(parkResult = NA))));
assumption
	 (((sideSense = BLOCKED) & (parkResult = NA)));
assumption
	alw (((throttle = STOP) -> ((obstacle = next(obstacle)) & (sideSense = next(sideSense)))));
assumption
	alwEv (eNV_CONSTRAINT_0_respondsTo_responded);

guarantee
	 ((spec_policy = SEEKING));
guarantee
	alwEv ((spec_policy = PARKED));
guarantee
	alw (((spec_policy = SEEKING) -> (((next(spec_policy = SEEKING)) | (next(spec_policy = MEASURING))) | (next(spec_policy = PARKING_0)))));
guarantee
	alw (((spec_policy = MEASURING) -> (((next(spec_policy = SEEKING)) | (next(spec_policy = MEASURING))) | (next(spec_policy = PARKING_0)))));
guarantee
	alw (((spec_policy = PARKING_0) -> (next(spec_policy = PARKING_1))));
guarantee
	alw (((spec_policy = PARKING_1) -> (next(spec_policy = PARKING_2))));
guarantee
	alw (((spec_policy = PARKING_2) -> (next(spec_policy = PARKED))));
guarantee
	alw (((obstacle = BLOCKED) -> !((throttle = FWD))));
guarantee
	alw (((sideSense = BLOCKED) -> !(((steer = RIGHT) & (throttle = FWD)))));
guarantee
	alw ((((obstacle = BLOCKED) & ((spec_policy = MEASURING) | (spec_policy = SEEKING))) -> (next(spec_policy = SEEKING))));
guarantee
	alw (((obstacle = BLOCKED) -> (parkCommand = STOP)));
guarantee
	alw ((((spec_policy = SEEKING) & (parkResult = NA)) -> !((throttle = STOP))));
guarantee
	alw (((((spec_policy = SEEKING) & (sideSense = BLOCKED)) & (parkResult = NA)) -> ((next(spec_policy = spec_policy)) & (parkCommand = STOP))));
guarantee
	alw ((((((spec_policy = SEEKING) & (sideSense = CLEAR)) & (obstacle = CLEAR)) & (parkResult = NA)) -> ((((next(spec_policy = MEASURING)) & (throttle = FWD)) & (parkCommand = START)) & (steer = CENTER))));
guarantee
	alw (((((spec_policy = MEASURING) & (sideSense = BLOCKED)) & (parkResult = NA)) -> ((next(spec_policy = SEEKING)) & (parkCommand = STOP))));
guarantee
	alw ((((((spec_policy = MEASURING) & (sideSense = CLEAR)) & (obstacle = CLEAR)) & (parkResult = NA)) -> ((((next(spec_policy = spec_policy)) & (throttle = FWD)) & (parkCommand = CHECK)) & (steer = CENTER))));
guarantee
	alw ((((((spec_policy = MEASURING) | ((spec_policy = SEEKING) & pREV_aux_1)) & (obstacle = CLEAR)) & (parkResult = PARALLEL)) -> ((((next(spec_policy = PARKING_0)) & (throttle = STOP)) & (parkCommand = STOP)) & (steer = RIGHT))));
guarantee
	alw (((spec_policy = PARKING_0) -> ((((next(spec_policy = PARKING_1)) & (throttle = BWD)) & (steer = RIGHT)) & (parkCommand = STOP))));
guarantee
	alw (((spec_policy = PARKING_1) -> ((((next(spec_policy = PARKING_2)) & (throttle = STOP)) & (steer = LEFT)) & (parkCommand = STOP))));
guarantee
	alw (((spec_policy = PARKING_2) -> ((((next(spec_policy = PARKED)) & (throttle = BWD)) & (steer = LEFT)) & (parkCommand = STOP))));
guarantee
	alw (((spec_policy = PARKED) -> ((((next(spec_policy = spec_policy)) & (throttle = STOP)) & (steer = CENTER)) & (parkCommand = STOP))));

assumption
	 (eNV_CONSTRAINT_0_respondsTo_responded);
assumption
	alw ((next(eNV_CONSTRAINT_0_respondsTo_responded) <-> ((obstacle = CLEAR) | (eNV_CONSTRAINT_0_respondsTo_responded & !((throttle = BWD))))));
assumption
	 (!(pREV_aux_1));
assumption
	alw ((next(pREV_aux_1) <-> (spec_policy = MEASURING)));


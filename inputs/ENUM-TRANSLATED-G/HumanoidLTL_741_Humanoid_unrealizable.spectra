
module HumanoidLTL_741_Humanoid_unrealizable

env {CLEAR, BLOCKED} obstacle;
env {QUIET, NOISE} noise;
env {N, SO} heading;
env {FREE, PRESSED} button;

sys {FWD, BWD, STOP, TURN_FWD, TURN_BWD, CALIB_TURN, CALIB_FWD} leftMotor;
sys {FWD, BWD, STOP, TURN_FWD, TURN_BWD, CALIB_TURN, CALIB_FWD} rightMotor;
sys {FWD, BWD, STOP} headMotor;
sys {FWD, BWD, TURN_LEFT_1, TURN_LEFT_2} nextMoveMode;
sys {Q0, Q1, Q2, Q3} spec_state;
sys {M0, M1} search;
sys {N, SO} next_head;

aux boolean eNV_CONSTRAINT_0_respondsTo_responded;
aux boolean eNV_CONSTRAINT_1_respondsTo_responded;
aux boolean pREV_aux_2;
aux boolean pREV_aux_3;
aux boolean pREV_aux_4;

assumption
	G (((((nextMoveMode = FWD) | (nextMoveMode = BWD)) & !((heading = next_head))) -> !((next(heading) = next_head))));
assumption
	G ((((nextMoveMode = FWD) & (obstacle = BLOCKED)) -> (next(obstacle) = BLOCKED)));
assumption
	G ((((nextMoveMode = BWD) & (obstacle = CLEAR)) -> !((next(obstacle) = BLOCKED))));
assumption
	GF (eNV_CONSTRAINT_0_respondsTo_responded);
assumption
	GF (eNV_CONSTRAINT_1_respondsTo_responded);

guarantee
	 (((search = M0) & (spec_state = Q0)));
guarantee
	G ((next_head = N));
guarantee
	GF (((nextMoveMode = FWD) & (search = M0)));
guarantee
	G (((((spec_state = Q0) & (nextMoveMode = FWD)) & (next(nextMoveMode) = BWD)) -> (next(spec_state) = Q1)));
guarantee
	G (((((spec_state = Q1) & (nextMoveMode = BWD)) & (next(nextMoveMode) = FWD)) -> (next(spec_state) = Q2)));
guarantee
	G (!((((spec_state = Q2) & (nextMoveMode = FWD)) & (next(nextMoveMode) = BWD))));
guarantee
	G ((((nextMoveMode = TURN_LEFT_1) | (nextMoveMode = TURN_LEFT_2)) -> (next(spec_state) = Q0)));
guarantee
	G (((((pREV_aux_2 & (noise = NOISE)) & !((heading = next_head))) & !((button = PRESSED))) -> (search = M1)));
guarantee
	G (((pREV_aux_3 & (heading = next_head)) -> (search = M0)));
guarantee
	G (((pREV_aux_3 & !((heading = next_head))) -> (search = M1)));
guarantee
	G ((((next(obstacle) = BLOCKED) & !(pREV_aux_4)) -> !((next(nextMoveMode) = FWD))));
guarantee
	G ((((nextMoveMode = BWD) & (next(nextMoveMode) = FWD)) <-> ((next(leftMotor) = FWD) & (next(rightMotor) = BWD))));
guarantee
	G ((((nextMoveMode = FWD) & (next(nextMoveMode) = BWD)) <-> ((next(leftMotor) = BWD) & (next(rightMotor) = FWD))));
guarantee
	G (((next(nextMoveMode) = BWD) -> ((nextMoveMode = FWD) | (nextMoveMode = BWD))));
guarantee
	G (((nextMoveMode = TURN_LEFT_1) -> ((next(leftMotor) = FWD) & (next(rightMotor) = TURN_FWD))));
guarantee
	G (((nextMoveMode = TURN_LEFT_2) -> ((next(leftMotor) = BWD) & (next(rightMotor) = TURN_BWD))));
guarantee
	G (((nextMoveMode = TURN_LEFT_1) <-> (next(nextMoveMode) = TURN_LEFT_2)));
guarantee
	G ((!(((nextMoveMode = TURN_LEFT_1) | (nextMoveMode = TURN_LEFT_2))) -> !(((((next(leftMotor) = TURN_BWD) | (next(rightMotor) = TURN_BWD)) | (next(leftMotor) = TURN_FWD)) | (next(rightMotor) = TURN_FWD)))));
guarantee
	G ((((nextMoveMode = FWD) & (next(nextMoveMode) = TURN_LEFT_1)) <-> ((next(leftMotor) = CALIB_TURN) & (next(rightMotor) = CALIB_TURN))));
guarantee
	G ((((nextMoveMode = FWD) & pREV_aux_4) <-> ((next(leftMotor) = CALIB_FWD) & (next(rightMotor) = CALIB_FWD))));
guarantee
	G (((nextMoveMode = BWD) -> !((next(nextMoveMode) = TURN_LEFT_1))));

guarantee
	 (eNV_CONSTRAINT_0_respondsTo_responded);
guarantee
	G ((next(eNV_CONSTRAINT_0_respondsTo_responded) <-> ((heading = next_head) | (eNV_CONSTRAINT_0_respondsTo_responded & !((search = M1))))));
guarantee
	 (eNV_CONSTRAINT_1_respondsTo_responded);
guarantee
	G ((next(eNV_CONSTRAINT_1_respondsTo_responded) <-> (((nextMoveMode = TURN_LEFT_2) & (obstacle = CLEAR)) | (eNV_CONSTRAINT_1_respondsTo_responded & !((nextMoveMode = TURN_LEFT_2))))));
guarantee
	 (!(pREV_aux_2));
guarantee
	G ((next(pREV_aux_2) <-> (search = M0)));
guarantee
	 (!(pREV_aux_3));
guarantee
	G ((next(pREV_aux_3) <-> (search = M1)));
guarantee
	 (!(pREV_aux_4));
guarantee
	G ((next(pREV_aux_4) <-> (nextMoveMode = TURN_LEFT_2)));



module HumanoidLTL_NotRealizable2_884_Humanoid_unrealizable

env {CLEAR, BLOCKED} obstacle;
env {QUIET, NOISE} noise;
env {N, NW, W, SW, SO, SE, EA, NE} heading;
env {FREE, PRESSED} button;

sys {FWD, BWD, STOP, TURN_FWD, TURN_BWD, CALIB_TURN, CALIB_FWD} leftMotor;
sys {FWD, BWD, STOP, TURN_FWD, TURN_BWD, CALIB_TURN, CALIB_FWD} rightMotor;
sys {FWD, BWD, STOP} headMotor;
sys {FWD, BWD, TURN_LEFT_1, TURN_LEFT_2} spec_nextMoveMode;
sys {Q0, Q1, Q2, Q3} spec_state;
sys {M0, M1} spec_search;
sys {N, NW, W, SW, SO, SE, EA, NE} next_head;

aux boolean eNV_CONSTRAINT_0_respondsTo_responded;
aux boolean eNV_CONSTRAINT_1_respondsTo_responded;
aux boolean eNV_CONSTRAINT_2_respondsTo_responded;
aux boolean pREV_aux_3;
aux boolean pREV_aux_4;
aux boolean pREV_aux_5;
aux boolean pREV_aux_6;
aux boolean pREV_aux_7;

assumption
	G (((((spec_nextMoveMode = FWD) | (spec_nextMoveMode = BWD)) & !((heading = next_head))) -> !((next(heading) = next(next_head)))));
assumption
	G ((((spec_nextMoveMode = BWD) & (obstacle = CLEAR)) -> !((next(obstacle) = BLOCKED))));
assumption
	GF ((pREV_aux_3 & (obstacle = CLEAR)));
assumption
	GF (eNV_CONSTRAINT_0_respondsTo_responded);
assumption
	GF (eNV_CONSTRAINT_1_respondsTo_responded);
assumption
	GF (eNV_CONSTRAINT_2_respondsTo_responded);

guarantee
	 (((spec_search = M0) & (next_head = N)));
guarantee
	G (((((spec_state = Q0) & (spec_nextMoveMode = FWD)) & (next(spec_nextMoveMode) = BWD)) -> (next(spec_state) = Q1)));
guarantee
	G (((((spec_state = Q1) & (spec_nextMoveMode = BWD)) & (next(spec_nextMoveMode) = FWD)) -> (next(spec_state) = Q2)));
guarantee
	G (!((((spec_state = Q2) & (spec_nextMoveMode = FWD)) & (next(spec_nextMoveMode) = BWD))));
guarantee
	G ((((spec_state = Q1) & (next(spec_nextMoveMode) = BWD)) -> (next(spec_state) = Q1)));
guarantee
	G ((((spec_state = Q2) & (next(spec_nextMoveMode) = FWD)) -> (next(spec_state) = Q2)));
guarantee
	G ((((spec_nextMoveMode = TURN_LEFT_1) | (spec_nextMoveMode = TURN_LEFT_2)) -> (next(spec_state) = Q0)));
guarantee
	G (((button = PRESSED) -> (next_head = heading)));
guarantee
	G ((((((spec_search = M0) & (spec_nextMoveMode = FWD)) & (noise = NOISE)) & !((heading = next_head))) -> (next(spec_search) = M1)));
guarantee
	G ((((spec_search = M1) & (heading = next_head)) -> (next(spec_search) = M0)));
guarantee
	G ((((obstacle = BLOCKED) & !(pREV_aux_4)) -> !((spec_nextMoveMode = FWD))));
guarantee
	G (((pREV_aux_5 & (spec_nextMoveMode = FWD)) <-> ((leftMotor = FWD) & (rightMotor = BWD))));
guarantee
	G (((pREV_aux_6 & (spec_nextMoveMode = BWD)) <-> ((leftMotor = BWD) & (rightMotor = FWD))));
guarantee
	GF ((spec_nextMoveMode = FWD));
guarantee
	G ((pREV_aux_7 -> ((leftMotor = FWD) & (rightMotor = TURN_FWD))));
guarantee
	G ((pREV_aux_3 -> ((leftMotor = BWD) & (rightMotor = TURN_BWD))));
guarantee
	G ((pREV_aux_7 <-> (spec_nextMoveMode = TURN_LEFT_2)));
guarantee
	G ((!((pREV_aux_7 | pREV_aux_3)) -> !(((((leftMotor = TURN_BWD) | (rightMotor = TURN_BWD)) | (leftMotor = TURN_FWD)) | (rightMotor = TURN_FWD)))));
guarantee
	G (((spec_nextMoveMode = BWD) -> (pREV_aux_6 | pREV_aux_5)));
guarantee
	G (((pREV_aux_6 & (spec_nextMoveMode = TURN_LEFT_1)) <-> ((leftMotor = CALIB_TURN) & (rightMotor = CALIB_TURN))));
guarantee
	G (((pREV_aux_6 & pREV_aux_4) <-> ((leftMotor = CALIB_FWD) & (rightMotor = CALIB_FWD))));
guarantee
	G ((pREV_aux_5 -> !((spec_nextMoveMode = TURN_LEFT_1))));

guarantee
	 (eNV_CONSTRAINT_0_respondsTo_responded);
guarantee
	G ((next(eNV_CONSTRAINT_0_respondsTo_responded) <-> ((heading = next_head) | (eNV_CONSTRAINT_0_respondsTo_responded & !((spec_search = M1))))));
guarantee
	 (eNV_CONSTRAINT_1_respondsTo_responded);
guarantee
	G ((next(eNV_CONSTRAINT_1_respondsTo_responded) <-> (((heading = next_head) | (!((spec_nextMoveMode = TURN_LEFT_2)) & !((spec_nextMoveMode = TURN_LEFT_2)))) | (eNV_CONSTRAINT_1_respondsTo_responded & !((spec_nextMoveMode = TURN_LEFT_1))))));
guarantee
	 (eNV_CONSTRAINT_2_respondsTo_responded);
guarantee
	G ((next(eNV_CONSTRAINT_2_respondsTo_responded) <-> ((obstacle = CLEAR) | (eNV_CONSTRAINT_2_respondsTo_responded & !(!((spec_nextMoveMode = FWD)))))));
guarantee
	 (!(pREV_aux_3));
guarantee
	G ((next(pREV_aux_3) <-> (spec_nextMoveMode = TURN_LEFT_2)));
guarantee
	 (!(pREV_aux_4));
guarantee
	G ((next(pREV_aux_4) <-> pREV_aux_3));
guarantee
	 (!(pREV_aux_5));
guarantee
	G ((next(pREV_aux_5) <-> (spec_nextMoveMode = BWD)));
guarantee
	 (!(pREV_aux_6));
guarantee
	G ((next(pREV_aux_6) <-> (spec_nextMoveMode = FWD)));
guarantee
	 (!(pREV_aux_7));
guarantee
	G ((next(pREV_aux_7) <-> (spec_nextMoveMode = TURN_LEFT_1)));


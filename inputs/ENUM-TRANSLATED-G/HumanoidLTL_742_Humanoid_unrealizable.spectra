
module HumanoidLTL_742_Humanoid_unrealizable

env {CLEAR, BLOCKED} obstacle;

sys {FWD, BWD, STOP, TURN_FWD, TURN_BWD, CALIB_TURN, CALIB_FWD} leftMotor;
sys {FWD, BWD, STOP, TURN_FWD, TURN_BWD, CALIB_TURN, CALIB_FWD} rightMotor;
sys {FWD, BWD, STOP} headMotor;
sys {FWD, BWD, TURN_LEFT} nextMoveMode;
sys {Q0, Q1, Q2, Q3} specState;
sys {T0, T1, T2, T3} turnState;

env boolean pREV_aux_0;
env boolean pREV_aux_1;

assumption
	G (((pREV_aux_0 & (obstacle = BLOCKED)) -> (next(obstacle = BLOCKED))));
assumption
	G (((pREV_aux_1 & (obstacle = CLEAR)) -> !((next(obstacle = BLOCKED)))));

guarantee
	 ((specState = Q0));
guarantee
	 ((turnState = T0));
guarantee
	alwEv ((next(nextMoveMode = FWD)));
guarantee
	G (((((specState = Q0) & (next(nextMoveMode = FWD))) & (next(nextMoveMode = BWD))) -> (next(specState = Q1))));
guarantee
	G (((((specState = Q1) & (next(nextMoveMode = BWD))) & (next(nextMoveMode = FWD))) -> (next(specState = Q2))));
guarantee
	G (!((((specState = Q2) & (next(nextMoveMode = FWD))) & (next(nextMoveMode = BWD)))));
guarantee
	G ((((specState = Q1) & (next(nextMoveMode = BWD))) -> (next(specState = Q1))));
guarantee
	G ((((specState = Q2) & (next(nextMoveMode = FWD))) -> (next(specState = Q2))));
guarantee
	G (((next(nextMoveMode = TURN_LEFT)) -> (next(specState = Q0))));
guarantee
	G (((obstacle = BLOCKED) -> !((next(nextMoveMode = FWD)))));
guarantee
	G ((((next(nextMoveMode = BWD)) & (next(nextMoveMode = FWD))) <-> ((next(leftMotor = FWD)) & (next(rightMotor = BWD)))));
guarantee
	G ((((next(nextMoveMode = FWD)) & (next(nextMoveMode = BWD))) <-> ((next(leftMotor = BWD)) & (next(rightMotor = FWD)))));
guarantee
	G (((next(nextMoveMode = BWD)) -> ((next(nextMoveMode = FWD)) | (next(nextMoveMode = BWD)))));
guarantee
	G (((next(nextMoveMode = BWD)) -> ((next(nextMoveMode = FWD)) | (next(nextMoveMode = BWD)))));
guarantee
	G (((next(turnState = T0)) -> ((turnState = T0) | (turnState = T3))));
guarantee
	G ((((turnState = T0) & !((next(nextMoveMode = TURN_LEFT)))) -> (next(turnState = T0))));
guarantee
	G (((((next(nextMoveMode = TURN_LEFT)) & pREV_aux_0) & (turnState = T0)) -> (next(turnState = T1))));
guarantee
	G (((turnState = T1) -> ((next(turnState = T2)) & (next(nextMoveMode = TURN_LEFT)))));
guarantee
	G ((((turnState = T2) & (next(nextMoveMode = TURN_LEFT))) -> (next(turnState = T1))));
guarantee
	G ((((turnState = T2) & (next(nextMoveMode = FWD))) -> (next(turnState = T3))));
guarantee
	G ((((turnState = T3) & (next(nextMoveMode = FWD))) -> (next(turnState = T0))));
guarantee
	G ((((turnState = T3) & !((next(nextMoveMode = FWD)))) -> (next(turnState = T2))));
guarantee
	G ((((turnState = T2) & (obstacle = CLEAR)) -> (next(nextMoveMode = FWD))));
guarantee
	G ((((turnState = T0) & (next(turnState = T1))) <-> ((leftMotor = CALIB_TURN) & (rightMotor = CALIB_TURN))));
guarantee
	G (((next(turnState = T2)) <-> ((leftMotor = FWD) & (rightMotor = TURN_FWD))));
guarantee
	G (((turnState = T2) <-> ((leftMotor = BWD) & (rightMotor = TURN_BWD))));
guarantee
	G ((((turnState = T3) & (turnState = T0)) <-> ((leftMotor = CALIB_FWD) & (rightMotor = CALIB_FWD))));

assumption
	 (!(pREV_aux_0));
assumption
	G ((next(pREV_aux_0) <-> (next(nextMoveMode = FWD))));
assumption
	 (!(pREV_aux_1));
assumption
	G ((next(pREV_aux_1) <-> (next(nextMoveMode = BWD))));


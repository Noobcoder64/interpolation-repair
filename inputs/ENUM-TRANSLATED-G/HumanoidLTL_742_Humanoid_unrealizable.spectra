
module HumanoidLTL_742_Humanoid_unrealizable

env {CLEAR, BLOCKED} obstacle;

sys {FWD, BWD, STOP, TURN_FWD, TURN_BWD, CALIB_TURN, CALIB_FWD} leftMotor;
sys {FWD, BWD, STOP, TURN_FWD, TURN_BWD, CALIB_TURN, CALIB_FWD} rightMotor;
sys {FWD, BWD, STOP} headMotor;
sys {FWD, BWD, TURN_LEFT} nextMoveMode;
sys {Q0, Q1, Q2, Q3} specState;
sys {T0, T1, T2, T3} turnState;

aux boolean pREV_aux_0;
aux boolean pREV_aux_1;

assumption
	G (((pREV_aux_0 & (obstacle = BLOCKED)) -> (next(obstacle) = BLOCKED)));
assumption
	G (((pREV_aux_1 & (obstacle = CLEAR)) -> !((next(obstacle) = BLOCKED))));

guarantee
	 ((specState = Q0));
guarantee
	 ((turnState = T0));
guarantee
	GF ((nextMoveMode = FWD));
guarantee
	G (((((specState = Q0) & (nextMoveMode = FWD)) & (next(nextMoveMode) = BWD)) -> (next(specState) = Q1)));
guarantee
	G (((((specState = Q1) & (nextMoveMode = BWD)) & (next(nextMoveMode) = FWD)) -> (next(specState) = Q2)));
guarantee
	G (!((((specState = Q2) & (nextMoveMode = FWD)) & (next(nextMoveMode) = BWD))));
guarantee
	G ((((specState = Q1) & (next(nextMoveMode) = BWD)) -> (next(specState) = Q1)));
guarantee
	G ((((specState = Q2) & (next(nextMoveMode) = FWD)) -> (next(specState) = Q2)));
guarantee
	G (((nextMoveMode = TURN_LEFT) -> (next(specState) = Q0)));
guarantee
	G (((obstacle = BLOCKED) -> !((nextMoveMode = FWD))));
guarantee
	G ((((nextMoveMode = BWD) & (next(nextMoveMode) = FWD)) <-> ((next(leftMotor) = FWD) & (next(rightMotor) = BWD))));
guarantee
	G ((((nextMoveMode = FWD) & (next(nextMoveMode) = BWD)) <-> ((next(leftMotor) = BWD) & (next(rightMotor) = FWD))));
guarantee
	G (((next(nextMoveMode) = BWD) -> ((nextMoveMode = FWD) | (nextMoveMode = BWD))));
guarantee
	G (((nextMoveMode = BWD) -> ((next(nextMoveMode) = FWD) | (next(nextMoveMode) = BWD))));
guarantee
	G (((next(turnState) = T0) -> ((turnState = T0) | (turnState = T3))));
guarantee
	G ((((turnState = T0) & !((nextMoveMode = TURN_LEFT))) -> (next(turnState) = T0)));
guarantee
	G (((((nextMoveMode = TURN_LEFT) & pREV_aux_0) & (turnState = T0)) -> (next(turnState) = T1)));
guarantee
	G (((turnState = T1) -> ((next(turnState) = T2) & (nextMoveMode = TURN_LEFT))));
guarantee
	G ((((turnState = T2) & (nextMoveMode = TURN_LEFT)) -> (next(turnState) = T1)));
guarantee
	G ((((turnState = T2) & (nextMoveMode = FWD)) -> (next(turnState) = T3)));
guarantee
	G ((((turnState = T3) & (nextMoveMode = FWD)) -> (next(turnState) = T0)));
guarantee
	G ((((turnState = T3) & !((nextMoveMode = FWD))) -> (next(turnState) = T2)));
guarantee
	G ((((turnState = T2) & (obstacle = CLEAR)) -> (nextMoveMode = FWD)));
guarantee
	G ((((turnState = T0) & (next(turnState) = T1)) <-> ((leftMotor = CALIB_TURN) & (rightMotor = CALIB_TURN))));
guarantee
	G (((next(turnState) = T2) <-> ((leftMotor = FWD) & (rightMotor = TURN_FWD))));
guarantee
	G (((turnState = T2) <-> ((leftMotor = BWD) & (rightMotor = TURN_BWD))));
guarantee
	G ((((turnState = T3) & (turnState = T0)) <-> ((leftMotor = CALIB_FWD) & (rightMotor = CALIB_FWD))));

guarantee
	 (!(pREV_aux_0));
guarantee
	G ((next(pREV_aux_0) <-> (nextMoveMode = FWD)));
guarantee
	 (!(pREV_aux_1));
guarantee
	G ((next(pREV_aux_1) <-> (nextMoveMode = BWD)));


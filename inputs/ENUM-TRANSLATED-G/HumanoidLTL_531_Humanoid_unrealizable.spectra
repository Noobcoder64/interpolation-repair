
module HumanoidLTL_531_Humanoid_unrealizable

env {CLEAR, BLOCKED} obstacle;

sys {FWD, BWD, STOP, TURN_FWD, TURN_BWD, CALIB_TURN, CALIB_FWD} leftMotor;
sys {FWD, BWD, STOP, TURN_FWD, TURN_BWD, CALIB_TURN, CALIB_FWD} rightMotor;
sys {FWD, BWD, STOP} headMotor;
sys {FWD, BWD, TURN_LEFT_1, TURN_LEFT_2} moveMode;
sys {Q0, Q1, Q2, Q3} state;

env boolean eNV_CONSTRAINT_0_respondsTo_responded;
env boolean pREV_aux_1;

assumption
	alwEv ((obstacle = CLEAR));
assumption
	alwEv (eNV_CONSTRAINT_0_respondsTo_responded);

guarantee
	G (((((state = Q0) & (moveMode = FWD)) & (next(moveMode = BWD))) -> (next(state = Q1))));
guarantee
	G (((((state = Q1) & (moveMode = BWD)) & (next(moveMode = FWD))) -> (next(state = Q2))));
guarantee
	G (((((state = Q2) & (moveMode = FWD)) & (next(moveMode = BWD))) -> (next(state = Q3))));
guarantee
	G ((((state = Q1) & (next(moveMode = BWD))) -> (next(state = Q1))));
guarantee
	G ((((state = Q2) & (next(moveMode = FWD))) -> (next(state = Q2))));
guarantee
	G (!((state = Q3)));
guarantee
	G ((((moveMode = FWD) & (obstacle = BLOCKED)) -> !((next(moveMode = FWD)))));
guarantee
	G (((((moveMode = FWD) & (next(moveMode = BWD))) | ((moveMode = BWD) & (next(moveMode = FWD)))) <-> (((leftMotor = FWD) & (rightMotor = BWD)) | ((leftMotor = BWD) & (rightMotor = FWD)))));
guarantee
	alwEv ((moveMode = FWD));
guarantee
	G (((moveMode = TURN_LEFT_2) -> !((next(moveMode = BWD)))));
guarantee
	G ((((moveMode = FWD) & (next(moveMode = TURN_LEFT_1))) <-> ((leftMotor = CALIB_TURN) & (rightMotor = CALIB_TURN))));
guarantee
	G ((((moveMode = FWD) & pREV_aux_1) <-> ((leftMotor = CALIB_FWD) & (rightMotor = CALIB_FWD))));
guarantee
	G (((moveMode = TURN_LEFT_1) <-> (next(moveMode = TURN_LEFT_2))));
guarantee
	G (((moveMode = TURN_LEFT_1) -> ((leftMotor = FWD) & (rightMotor = TURN_FWD))));
guarantee
	G (((moveMode = TURN_LEFT_2) -> ((leftMotor = BWD) & (rightMotor = TURN_BWD))));
guarantee
	G ((!(((moveMode = TURN_LEFT_1) | (moveMode = TURN_LEFT_2))) -> !(((((leftMotor = TURN_BWD) | (rightMotor = TURN_BWD)) | (leftMotor = TURN_FWD)) | (rightMotor = TURN_FWD)))));

assumption
	 (eNV_CONSTRAINT_0_respondsTo_responded);
assumption
	G ((next(eNV_CONSTRAINT_0_respondsTo_responded) <-> ((obstacle = CLEAR) | (eNV_CONSTRAINT_0_respondsTo_responded & !((((moveMode = BWD) | (moveMode = TURN_LEFT_1)) | (moveMode = TURN_LEFT_2)))))));
assumption
	 (!(pREV_aux_1));
assumption
	G ((next(pREV_aux_1) <-> (moveMode = TURN_LEFT_2)));

